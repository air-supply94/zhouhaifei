(function(global,factory){typeof exports==='object'&&typeof module!=='undefined'?factory(exports,require('mobx'),require('react'),require('mobx-react-lite')):typeof define==='function'&&define.amd?define(['exports','mobx','react','mobx-react-lite'],factory):(global=global||self,factory(global.mobxReact={},global.mobx,global.React,global.mobxReactLite));}(this,(function(exports,mobx,React,mobxReactLite){'use strict';var React__default='default'in React?React['default']:React;var symbolId=0;function createSymbol(name){if(typeof Symbol==="function"){return Symbol(name);}var symbol="__$mobx-react "+name+" ("+symbolId+")";symbolId++;return symbol;}var createdSymbols={};function newSymbol(name){if(!createdSymbols[name]){createdSymbols[name]=createSymbol(name);}return createdSymbols[name];}function shallowEqual(objA,objB){if(is(objA,objB))return true;if(typeof objA!=="object"||objA===null||typeof objB!=="object"||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length)return false;for(var i=0;i<keysA.length;i++){if(!Object.hasOwnProperty.call(objB,keysA[i])||!is(objA[keysA[i]],objB[keysA[i]])){return false;}}return true;}function is(x,y){if(x===y){return x!==0||1/x===1/y;}else{return x!==x&&y!==y;}}var hoistBlackList={$$typeof:1,render:1,compare:1,type:1,childContextTypes:1,contextType:1,contextTypes:1,defaultProps:1,getDefaultProps:1,getDerivedStateFromError:1,getDerivedStateFromProps:1,mixins:1,propTypes:1};function copyStaticProperties(base,target){var protoProps=Object.getOwnPropertyNames(Object.getPrototypeOf(base));Object.getOwnPropertyNames(base).forEach(function(key){if(!hoistBlackList[key]&&protoProps.indexOf(key)===-1){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(base,key));}});}function setHiddenProp(target,prop,value){if(!Object.hasOwnProperty.call(target,prop)){Object.defineProperty(target,prop,{enumerable:false,configurable:true,writable:true,value:value});}else{target[prop]=value;}}var mobxMixins=newSymbol("patchMixins");var mobxPatchedDefinition=newSymbol("patchedDefinition");function getMixins(target,methodName){var mixins=target[mobxMixins]=target[mobxMixins]||{};var methodMixins=mixins[methodName]=mixins[methodName]||{};methodMixins.locks=methodMixins.locks||0;methodMixins.methods=methodMixins.methods||[];return methodMixins;}function wrapper(realMethod,mixins){var _this=this;for(var _len=arguments.length,args=new Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=arguments[_key];}mixins.locks++;try{var retVal;if(realMethod!==undefined&&realMethod!==null){retVal=realMethod.apply(this,args);}return retVal;}finally{mixins.locks--;if(mixins.locks===0){mixins.methods.forEach(function(mx){mx.apply(_this,args);});}}}function wrapFunction(realMethod,mixins){var fn=function fn(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}wrapper.call.apply(wrapper,[this,realMethod,mixins].concat(args));};return fn;}function patch(target,methodName,mixinMethod){var mixins=getMixins(target,methodName);if(mixins.methods.indexOf(mixinMethod)<0){mixins.methods.push(mixinMethod);}var oldDefinition=Object.getOwnPropertyDescriptor(target,methodName);if(oldDefinition&&oldDefinition[mobxPatchedDefinition]){return;}var originalMethod=target[methodName];var newDefinition=createDefinition(target,methodName,oldDefinition?oldDefinition.enumerable:undefined,mixins,originalMethod);Object.defineProperty(target,methodName,newDefinition);}function createDefinition(target,methodName,enumerable,mixins,originalMethod){var _ref;var wrappedFunc=wrapFunction(originalMethod,mixins);return _ref={},_ref[mobxPatchedDefinition]=true,_ref.get=function get(){return wrappedFunc;},_ref.set=function set(value){if(this===target){wrappedFunc=wrapFunction(value,mixins);}else{var newDefinition=createDefinition(this,methodName,enumerable,mixins,value);Object.defineProperty(this,methodName,newDefinition);}},_ref.configurable=true,_ref.enumerable=enumerable,_ref;}var mobxAdminProperty=mobx.$mobx||"$mobx";var mobxObserverProperty=newSymbol("isMobXReactObserver");var mobxIsUnmounted=newSymbol("isUnmounted");var skipRenderKey=newSymbol("skipRender");var isForcingUpdateKey=newSymbol("isForcingUpdate");function makeClassComponentObserver(componentClass){var target=componentClass.prototype;if(componentClass[mobxObserverProperty]){var displayName=getDisplayName(target);console.warn("The provided component class ("+displayName+") \n                has already been declared as an observer component.");}else{componentClass[mobxObserverProperty]=true;}if(target.componentWillReact)throw new Error("The componentWillReact life-cycle event is no longer supported");if(componentClass["__proto__"]!==React.PureComponent){if(!target.shouldComponentUpdate)target.shouldComponentUpdate=observerSCU;else if(target.shouldComponentUpdate!==observerSCU)throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");}makeObservableProp(target,"props");makeObservableProp(target,"state");var baseRender=target.render;target.render=function(){return makeComponentReactive.call(this,baseRender);};patch(target,"componentWillUnmount",function(){var _this$render$mobxAdmi;if(mobxReactLite.isUsingStaticRendering()===true)return;(_this$render$mobxAdmi=this.render[mobxAdminProperty])===null||_this$render$mobxAdmi===void 0?void 0:_this$render$mobxAdmi.dispose();this[mobxIsUnmounted]=true;if(!this.render[mobxAdminProperty]){var _displayName=getDisplayName(this);console.warn("The reactive render of an observer class component ("+_displayName+") \n                was overriden after MobX attached. This may result in a memory leak if the \n                overriden reactive render was not properly disposed.");}});return componentClass;}function getDisplayName(comp){return comp.displayName||comp.name||comp.constructor&&(comp.constructor.displayName||comp.constructor.name)||"<component>";}function makeComponentReactive(render){var _this=this;if(mobxReactLite.isUsingStaticRendering()===true)return render.call(this);setHiddenProp(this,skipRenderKey,false);setHiddenProp(this,isForcingUpdateKey,false);var initialName=getDisplayName(this);var baseRender=render.bind(this);var isRenderingPending=false;var reaction=new mobx.Reaction(initialName+".render()",function(){if(!isRenderingPending){isRenderingPending=true;if(_this[mobxIsUnmounted]!==true){var hasError=true;try{setHiddenProp(_this,isForcingUpdateKey,true);if(!_this[skipRenderKey])React.Component.prototype.forceUpdate.call(_this);hasError=false;}finally{setHiddenProp(_this,isForcingUpdateKey,false);if(hasError)reaction.dispose();}}}});reaction["reactComponent"]=this;reactiveRender[mobxAdminProperty]=reaction;this.render=reactiveRender;function reactiveRender(){isRenderingPending=false;var exception=undefined;var rendering=undefined;reaction.track(function(){try{rendering=mobx._allowStateChanges(false,baseRender);}catch(e){exception=e;}});if(exception){throw exception;}return rendering;}return reactiveRender.call(this);}function observerSCU(nextProps,nextState){if(mobxReactLite.isUsingStaticRendering()){console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.");}if(this.state!==nextState){return true;}return!shallowEqual(this.props,nextProps);}function makeObservableProp(target,propName){var valueHolderKey=newSymbol("reactProp_"+propName+"_valueHolder");var atomHolderKey=newSymbol("reactProp_"+propName+"_atomHolder");function getAtom(){if(!this[atomHolderKey]){setHiddenProp(this,atomHolderKey,mobx.createAtom("reactive "+propName));}return this[atomHolderKey];}Object.defineProperty(target,propName,{configurable:true,enumerable:true,get:function get(){var prevReadState=false;if(mobx._allowStateReadsStart&&mobx._allowStateReadsEnd){prevReadState=mobx._allowStateReadsStart(true);}getAtom.call(this).reportObserved();if(mobx._allowStateReadsStart&&mobx._allowStateReadsEnd){mobx._allowStateReadsEnd(prevReadState);}return this[valueHolderKey];},set:function set(v){if(!this[isForcingUpdateKey]&&!shallowEqual(this[valueHolderKey],v)){setHiddenProp(this,valueHolderKey,v);setHiddenProp(this,skipRenderKey,true);getAtom.call(this).reportChanged();setHiddenProp(this,skipRenderKey,false);}else{setHiddenProp(this,valueHolderKey,v);}}});}var hasSymbol=typeof Symbol==="function"&&Symbol.for;var ReactForwardRefSymbol=hasSymbol?Symbol.for("react.forward_ref"):typeof React.forwardRef==="function"&&React.forwardRef(function(props){return null;})["$$typeof"];var ReactMemoSymbol=hasSymbol?Symbol.for("react.memo"):typeof React.memo==="function"&&React.memo(function(props){return null;})["$$typeof"];function observer(component){if(component["isMobxInjector"]===true){console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'");}if(ReactMemoSymbol&&component["$$typeof"]===ReactMemoSymbol){throw new Error("Mobx observer: You are trying to use 'observer' on a function component wrapped in either another observer or 'React.memo'. The observer already applies 'React.memo' for you.");}if(ReactForwardRefSymbol&&component["$$typeof"]===ReactForwardRefSymbol){var baseRender=component["render"];if(typeof baseRender!=="function")throw new Error("render property of ForwardRef was not a function");return React.forwardRef(function ObserverForwardRef(){var args=arguments;return React.createElement(mobxReactLite.Observer,null,function(){return baseRender.apply(undefined,args);});});}if(typeof component==="function"&&(!component.prototype||!component.prototype.render)&&!component["isReactClass"]&&!Object.prototype.isPrototypeOf.call(React.Component,component)){return mobxReactLite.observer(component);}return makeClassComponentObserver(component);}function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}var MobXProviderContext=React__default.createContext({});function Provider(props){var children=props.children,stores=_objectWithoutPropertiesLoose(props,["children"]);var parentValue=React__default.useContext(MobXProviderContext);var mutableProviderRef=React__default.useRef(_extends({},parentValue,stores));var value=mutableProviderRef.current;{var newValue=_extends({},value,stores);if(!shallowEqual(value,newValue)){throw new Error("MobX Provider: The set of provided stores has changed. See: https://github.com/mobxjs/mobx-react#the-set-of-provided-stores-has-changed-error.");}}return React__default.createElement(MobXProviderContext.Provider,{value:value},children);}Provider.displayName="MobXProvider";function createStoreInjector(grabStoresFn,component,injectNames,makeReactive){var Injector=React__default.forwardRef(function(props,ref){var newProps=_extends({},props);var context=React__default.useContext(MobXProviderContext);Object.assign(newProps,grabStoresFn(context||{},newProps)||{});if(ref){newProps.ref=ref;}return React__default.createElement(component,newProps);});if(makeReactive)Injector=observer(Injector);Injector["isMobxInjector"]=true;copyStaticProperties(component,Injector);Injector["wrappedComponent"]=component;Injector.displayName=getInjectName(component,injectNames);return Injector;}function getInjectName(component,injectNames){var displayName;var componentName=component.displayName||component.name||component.constructor&&component.constructor.name||"Component";if(injectNames)displayName="inject-with-"+injectNames+"("+componentName+")";else displayName="inject("+componentName+")";return displayName;}function grabStoresByName(storeNames){return function(baseStores,nextProps){storeNames.forEach(function(storeName){if(storeName in nextProps)return;if(!(storeName in baseStores))throw new Error("MobX injector: Store '"+storeName+"' is not available! Make sure it is provided by some Provider");nextProps[storeName]=baseStores[storeName];});return nextProps;};}function inject(){for(var _len=arguments.length,storeNames=new Array(_len),_key=0;_key<_len;_key++){storeNames[_key]=arguments[_key];}if(typeof arguments[0]==="function"){var grabStoresFn=arguments[0];return function(componentClass){return createStoreInjector(grabStoresFn,componentClass,grabStoresFn.name,true);};}else{return function(componentClass){return createStoreInjector(grabStoresByName(storeNames),componentClass,storeNames.join("-"),false);};}}var protoStoreKey=newSymbol("disposeOnUnmountProto");var instStoreKey=newSymbol("disposeOnUnmountInst");function runDisposersOnWillUnmount(){var _this=this;[].concat(this[protoStoreKey]||[],this[instStoreKey]||[]).forEach(function(propKeyOrFunction){var prop=typeof propKeyOrFunction==="string"?_this[propKeyOrFunction]:propKeyOrFunction;if(prop!==undefined&&prop!==null){if(Array.isArray(prop))prop.map(function(f){return f();});else prop();}});}function disposeOnUnmount(target,propertyKeyOrFunction){if(Array.isArray(propertyKeyOrFunction)){return propertyKeyOrFunction.map(function(fn){return disposeOnUnmount(target,fn);});}var c=Object.getPrototypeOf(target).constructor;var c2=Object.getPrototypeOf(target.constructor);var c3=Object.getPrototypeOf(Object.getPrototypeOf(target));if(!(c===React__default.Component||c===React__default.PureComponent||c2===React__default.Component||c2===React__default.PureComponent||c3===React__default.Component||c3===React__default.PureComponent)){throw new Error("[mobx-react] disposeOnUnmount only supports direct subclasses of React.Component or React.PureComponent.");}if(typeof propertyKeyOrFunction!=="string"&&typeof propertyKeyOrFunction!=="function"&&!Array.isArray(propertyKeyOrFunction)){throw new Error("[mobx-react] disposeOnUnmount only works if the parameter is either a property key or a function.");}var isDecorator=typeof propertyKeyOrFunction==="string";var componentWasAlreadyModified=!!target[protoStoreKey]||!!target[instStoreKey];var store=isDecorator?target[protoStoreKey]||(target[protoStoreKey]=[]):target[instStoreKey]||(target[instStoreKey]=[]);store.push(propertyKeyOrFunction);if(!componentWasAlreadyModified){patch(target,"componentWillUnmount",runDisposersOnWillUnmount);}if(typeof propertyKeyOrFunction!=="string"){return propertyKeyOrFunction;}}function createChainableTypeChecker(validator){function checkType(isRequired,props,propName,componentName,location,propFullName){for(var _len=arguments.length,rest=new Array(_len>6?_len-6:0),_key=6;_key<_len;_key++){rest[_key-6]=arguments[_key];}return mobx.untracked(function(){componentName=componentName||"<<anonymous>>";propFullName=propFullName||propName;if(props[propName]==null){if(isRequired){var actual=props[propName]===null?"null":"undefined";return new Error("The "+location+" `"+propFullName+"` is marked as required "+"in `"+componentName+"`, but its value is `"+actual+"`.");}return null;}else{return validator.apply(void 0,[props,propName,componentName,location,propFullName].concat(rest));}});}var chainedCheckType=checkType.bind(null,false);chainedCheckType.isRequired=checkType.bind(null,true);return chainedCheckType;}function isSymbol(propType,propValue){if(propType==="symbol"){return true;}if(propValue["@@toStringTag"]==="Symbol"){return true;}if(typeof Symbol==="function"&&propValue instanceof Symbol){return true;}return false;}function getPropType(propValue){var propType=typeof propValue;if(Array.isArray(propValue)){return"array";}if(propValue instanceof RegExp){return"object";}if(isSymbol(propType,propValue)){return"symbol";}return propType;}function getPreciseType(propValue){var propType=getPropType(propValue);if(propType==="object"){if(propValue instanceof Date){return"date";}else if(propValue instanceof RegExp){return"regexp";}}return propType;}function createObservableTypeCheckerCreator(allowNativeType,mobxType){return createChainableTypeChecker(function(props,propName,componentName,location,propFullName){return mobx.untracked(function(){if(allowNativeType){if(getPropType(props[propName])===mobxType.toLowerCase())return null;}var mobxChecker;switch(mobxType){case"Array":mobxChecker=mobx.isObservableArray;break;case"Object":mobxChecker=mobx.isObservableObject;break;case"Map":mobxChecker=mobx.isObservableMap;break;default:throw new Error("Unexpected mobxType: "+mobxType);}var propValue=props[propName];if(!mobxChecker(propValue)){var preciseType=getPreciseType(propValue);var nativeTypeExpectationMessage=allowNativeType?" or javascript `"+mobxType.toLowerCase()+"`":"";return new Error("Invalid prop `"+propFullName+"` of type `"+preciseType+"` supplied to"+" `"+componentName+"`, expected `mobx.Observable"+mobxType+"`"+nativeTypeExpectationMessage+".");}return null;});});}function createObservableArrayOfTypeChecker(allowNativeType,typeChecker){return createChainableTypeChecker(function(props,propName,componentName,location,propFullName){for(var _len2=arguments.length,rest=new Array(_len2>5?_len2-5:0),_key2=5;_key2<_len2;_key2++){rest[_key2-5]=arguments[_key2];}return mobx.untracked(function(){if(typeof typeChecker!=="function"){return new Error("Property `"+propFullName+"` of component `"+componentName+"` has "+"invalid PropType notation.");}else{var error=createObservableTypeCheckerCreator(allowNativeType,"Array")(props,propName,componentName,location,propFullName);if(error instanceof Error)return error;var propValue=props[propName];for(var i=0;i<propValue.length;i++){error=typeChecker.apply(void 0,[propValue,i,componentName,location,propFullName+"["+i+"]"].concat(rest));if(error instanceof Error)return error;}return null;}});});}var observableArray=createObservableTypeCheckerCreator(false,"Array");var observableArrayOf=createObservableArrayOfTypeChecker.bind(null,false);var observableMap=createObservableTypeCheckerCreator(false,"Map");var observableObject=createObservableTypeCheckerCreator(false,"Object");var arrayOrObservableArray=createObservableTypeCheckerCreator(true,"Array");var arrayOrObservableArrayOf=createObservableArrayOfTypeChecker.bind(null,true);var objectOrObservableObject=createObservableTypeCheckerCreator(true,"Object");var PropTypes={observableArray:observableArray,observableArrayOf:observableArrayOf,observableMap:observableMap,observableObject:observableObject,arrayOrObservableArray:arrayOrObservableArray,arrayOrObservableArrayOf:arrayOrObservableArrayOf,objectOrObservableObject:objectOrObservableObject};if(!React.Component)throw new Error("mobx-react requires React to be available");if(!mobx.observable)throw new Error("mobx-react requires mobx to be available");Object.defineProperty(exports,'Observer',{enumerable:true,get:function(){return mobxReactLite.Observer;}});Object.defineProperty(exports,'isUsingStaticRendering',{enumerable:true,get:function(){return mobxReactLite.isUsingStaticRendering;}});Object.defineProperty(exports,'observerBatching',{enumerable:true,get:function(){return mobxReactLite.observerBatching;}});Object.defineProperty(exports,'useAsObservableSource',{enumerable:true,get:function(){return mobxReactLite.useAsObservableSource;}});Object.defineProperty(exports,'useLocalStore',{enumerable:true,get:function(){return mobxReactLite.useLocalStore;}});Object.defineProperty(exports,'useObserver',{enumerable:true,get:function(){return mobxReactLite.useObserver;}});Object.defineProperty(exports,'useStaticRendering',{enumerable:true,get:function(){return mobxReactLite.useStaticRendering;}});exports.MobXProviderContext=MobXProviderContext;exports.PropTypes=PropTypes;exports.Provider=Provider;exports.disposeOnUnmount=disposeOnUnmount;exports.inject=inject;exports.observer=observer;Object.defineProperty(exports,'__esModule',{value:true});})));
